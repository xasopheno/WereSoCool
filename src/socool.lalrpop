use std::str::FromStr;
use crate::ast::{Op};

grammar;

Comma<T>: Vec<T> = {
    <v:(<T> ",")*> <e:T?> => match e {
        None=> v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};

Overtone: Op = {
        "("
            <v:Value> ","
            <o:Value> ","
            <g:Value> ","
            <p:Value>
        ")"
        => Op::Compose { operations: vec! [
                Op::TransposeM { m: v },
                Op::TransposeA { a: o },
                Op::Gain { m: g },
                Op::PanA { a: p },
            ]
        }

}

Overtones = Comma<Overtone>;


Pipe<T>: Vec<T> = {
    <v:(<T> "|")*> <e:T?> => match e {
        None=> v,
        Some(e) => {
          let mut v = v;
          v.push(e);
          v
        }
    }
};

Operations = Comma<Operation>;

pub Operation: Op = {
    "AsIs" => Op::AsIs,
    "Reverse" => Op::Reverse,
    "Silence" <v:Value> => Op::Silence {m: v},
    "Tm" <v:Value> => Op::TransposeM {m: v},
    "Ta" <v:Value> => Op::TransposeA {a: v},
    "PanM" <v:Value> => Op::PanM {m: v},
    "PanA" <v:Value> => Op::PanA {a: v},
    "Length" <v:Value> => Op::Length {m: v},
    "Gain" <v:Value> => Op::Gain {m: v},
    "Sequence" "[" <operations: Operations> "]" => Op::Sequence { operations: operations },
    "Overlay" "[" <operations: Operations> "]" => Op::Overlay { operations: operations },
    "o" "[" <o: Overtones> "]" => Op::Overlay { operations: o }
};

Value: f32 = {
    <n:Num> => n,
    <n:Num> "/" <d:Num> => n/d

};

Num: f32 = <s:r"-?(0|([1-9]\d*))(\.\d+)?+"> => f32::from_str(s).unwrap();
