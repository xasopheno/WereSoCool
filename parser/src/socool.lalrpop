use num_rational::{Rational64};
use std::str::FromStr;
use std::string::String;
use socool_ast::{
    ast::{
        OpOrNfTable,
        Op,
        OpOrNf,
//        is_choice_op,
    },
};
use crate::parser::Init;
use crate::float_to_rational::helpers::*;

grammar<'table, 'err>(
    table: &'table mut OpOrNfTable,
);

pub SoCool: Init = {
  <init: Point>
  <l: LetDefs> => { init }
}

Point: Init = {
    "{"
         "f:" <f:Rational> ","
         "l:" <l:Rational> ","
         "g:" <g:Rational> ","
         "p:" <p:Rational>
    "}" ";"? => Init { f, l, g, p }
}

LetDefs = Lets<LetDef>;
LetDef: () = {
    <s: Name> "=" "{" <o: Operation> "}" => { table.insert(s.clone(), o); () },
}

Operation: OpOrNf = {
    <op1: Operation> ">" "FitLength" <op2: ComposeOperation> => {
        OpOrNf::Op(
            Op::Compose { operations:
            vec![op1.clone(), OpOrNf::Op(Op::WithLengthRatioOf { with_length_of: Box::new(op2), main: Box::new(op1) })]
        })
    },
    <op1: Operation> ">" "Repeat" <i: Int> => {
        let op = OpOrNf::Op(Op::AsIs);
    //    if is_choice_op(op1.clone(), table) {
    //        op = op1
    //    }
        let mut vec = Vec::new();
        for x in 0..i {
            vec.push(op.clone())
        }

        OpOrNf::Op(Op::Sequence { operations: vec })
    },

    <op: ComposeOperation> => op,
}

ComposeOperation: OpOrNf = {
    <ops: Pipe<BaseOperation>> => OpOrNf::Op(Op::Compose { operations: ops }),
    <o: BaseOperation> => o,
}

BaseOperation: OpOrNf = {
    "(" <o: Operation> ")" => o,
    "AsIs" => OpOrNf::Op(Op::AsIs {}),
    "Sine" => OpOrNf::Op(Op::Sine {}),
    "Square" => OpOrNf::Op(Op::Square {}),
    "Noise" => OpOrNf::Op(Op::Noise {}),
    "Reverse" => OpOrNf::Op(Op::Reverse {}),
    "Invert" => OpOrNf::Op(Op::FInvert),
    "Repeat" <i: Int> => {
        let mut vec = Vec::new();
        for x in 0..i {
            vec.push(OpOrNf::Op(Op::AsIs))
        }
        OpOrNf::Op(Op::Sequence { operations: vec })
    },
    "Silence" <v:Rational> => OpOrNf::Op(Op::Silence {m: v}),
    "Tm" <v:Rational> => OpOrNf::Op(Op::TransposeM {m: v}),
    "Ta" <v:Rational> => OpOrNf::Op(Op::TransposeA {a: v}),
    "PanM" <v:Rational> => OpOrNf::Op(Op::PanM {m: v}),
    "PanA" <v:Rational> => OpOrNf::Op(Op::PanA {a: v}),
    "Length" <v:Rational> => OpOrNf::Op(Op::Length {m: v}),
    "Gain" <v:Rational> => OpOrNf::Op(Op::Gain {m: v}),
    // "Choice" "[" <operations: Operations> "]" => OpOrNf::Op(Op::Choice { operations: operations }),
    "Sequence" "[" <operations: Operations> "]" => OpOrNf::Op(Op::Sequence { operations: operations }),
    "Overlay" "[" <operations: Operations> "]" => OpOrNf::Op(Op::Overlay { operations: operations }),
    "ModulateBy" "[" <operations: Operations> "]" => OpOrNf::Op(Op::ModulateBy { operations: operations }),
    "O" "[" <o: Overtones> "]" => OpOrNf::Op(Op::Overlay { operations: o }),
    <id_vec: Import> => {
        OpOrNf::Op(Op::Id(id_vec))
    },
};

Overtone: OpOrNf = {
    "("
        <fm:Rational> ","
        <fa:Rational> ","
        <g:Rational> ","
        <p:Rational>
    ")"
    => OpOrNf::Op(Op::Compose { operations: vec! [
            OpOrNf::Op(Op::TransposeM { m: fm }),
            OpOrNf::Op(Op::TransposeA { a: fa }),
            OpOrNf::Op(Op::Gain { m: g }),
            OpOrNf::Op(Op::PanA { a: p }),
        ]
    })
}

Overtones = Comma<Overtone>;

Comma<T>: Vec<T> = {
    <v:(<T> ",")*> <e:T?> => match e {
        None=> v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};

Import: Vec<String> = {
    <a: Name>"."<b: Name> => vec![a, b],
    <a: Name> => vec![a]
}

Lets<T>: Vec<T> = {
  <v:(<T>)*> => v
};

Pipe<T>: Vec<T> = {
    <v:(<T> "|")+> <e:T?> => match e {
        None=> v,
        Some(e) => {
          let mut v = v;
          v.push(e);
          v
        }
    }
};

Compose = Pipe<Operation>;

Operations = Comma<Operation>;

Rational: Rational64 = {
    <n: Float> => f32_to_rational(n),
    <n: Int> => Rational64::new(n, 1),
    <n: Int> "/" <d:Int> => Rational64::new(n, d),
};

Name: String = <s:r"[a-z_$][a-zA-Z_$0-9]*"> => s.to_string();
Float: String = <s:r"-?(0|([1-9]\d*))\.\d+"> => s.to_string();
Int: i64 = <s:r"-?[0-9]+"> => i64::from_str(s).unwrap();
